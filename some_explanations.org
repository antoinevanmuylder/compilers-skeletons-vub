* undead analysis :: asm-lang-v2/locals -> asm-lang-v2/undead
this pass decorates the code with undead out sets.
recall asm-lang-v2/locals syntax:
#+BEGIN_SRC bnf
 all we have is alocs. no registers and frame variables anymore
 p ::= (module info tail)
 tail ::= (halt triv)
          (begin effect ... tail)
 effect ::= (set! aloc triv)
            (set! aloc1 (binop aloc1 triv))
	    (begin effect ... effect)
 triv ::= int64 | aloc
#+END_SRC
Example of program
#+BEGIN_SRC racket
(begin
        (set! v.1 1)
        (set! w.2 46)
        (set! x.3 v.1)
        (set! p.1 7)
        (set! x.3 (+ x.3 p.1))
        (set! y.4 x.3)
        (set! p.1 4)
        (set! y.4 (+ y.4 p.1))
        (set! z.5 x.3)
        (set! z.5 (+ z.5 w.2))
        (set! t.6 y.4)
        (set! p.1 -1)
        (set! t.6 (* t.6 p.1))
        (set! z.5 (+ z.5 t.6))
        (halt z.5))
#+END_SRC
For each instruction we are going to compute its undead out set.
We start with the last instruction (which has an empty undead out set)
and go up in the instruction list (actually tree).
Lets say we've analysed instruction J which comes right after I in the program.
undead-out( I ) is computed like so:
- current UO( I ) is first defined as UO (J )
- then we remove some stuff from UO( I ): the variables appearing in J that are /assigned/ (left hand side)
  UO(I) = UO(I) - assigned vars from J
- and we add the variables that are /used/ (right hand side)
  UO(I) = UO(I) + used vars from J
#+BEGIN_SRC racket
(begin
        (set! v.1 1)
        (set! w.2 46)
        (set! x.3 v.1)
        (set! p.1 7)
        (set! x.3 (+ x.3 p.1))
        (set! y.4 x.3)
        (set! p.1 4)
        (set! y.4 (+ y.4 p.1))
        (set! z.5 x.3)
	...
        (set! z.5 (+ z.5 w.2))
	z.5 t.6 -> z.5 -> z.5 y.4
        (set! t.6 y.4)
	z.5 t.6 p.1 -> z.5 t.6
        (set! p.1 -1)
	z.5 t.6 -> z.5 -> z.5 t.6 p.1
        (set! t.6 (* t.6 p.1))
	z.5 -> EMPTY -> z.5 t.6 ;remove assigned THEN add used
        (set! z.5 (+ z.5 t.6))
	EMPTY -> z.5 ; z.5 used
        (halt z.5))
	EMPTY
#+END_SRC
* conflict analysis :: asm-lang-v2/undead -> asm-lang-v2/conflicts
This pass decorates the (already decorated) asm-lang-v2 program with a conflict graph.
It traverses the program in whatever order and for each instruction/undead-out pair (  (set! lhs rhs) , UO  ) it declares conflicts following those rules:
- Any variable defined during a non-move instruction is in conflict with every variable (except itself) in the undead-out set associated with the instruction. In other words, if the instruction is a non move instruction then we declare lhs in conflict with all the variables in UO.
- Any variable defined during a move instruction is in conflict with every variable in the undead-out set associated with the instruction, except itself and the variable referenced in the move. In other words, if the instruction is a move instruction (eg (set! aloc.1 aloc.2) we declare lhs to be in conflict with every variable appearing in UO except lhs and rhs.
We harvest the results of this analysis in an undirected graph structure.
#+BEGIN_SRC racket
(begin
        (set! v.1 1)
        (set! w.2 46)
        (set! x.3 v.1)
        (set! p.1 7)
        (set! x.3 (+ x.3 p.1))
        (set! y.4 x.3)
        (set! p.1 4)
        (set! y.4 (+ y.4 p.1))
        (set! z.5 x.3)
	...
        (set! z.5 (+ z.5 w.2))
	z.5 t.6 -> z.5 -> z.5 y.4
        (set! t.6 y.4)
	z.5 t.6 p.1 -> z.5 t.6 = UO | CONFLICT t.6 z.5 (move instruction but doesnt affect result)
        (set! p.1 -1)
	z.5 t.6 -> z.5 -> z.5 t.6 p.1
        (set! t.6 (* t.6 p.1))
	z.5 -> EMPTY -> z.5 t.6 ;remove assigned THEN add used
        (set! z.5 (+ z.5 t.6))
	EMPTY -> z.5 ; z.5 used
        (halt z.5))
	EMPTY
#+END_SRC
* assign-registers :: asm-lang-v2/conflicts -> asm-lang-v2/assignments
the source language is decorated with a conflict graph (uncolored, undirected, irreflexive graph).
We assign the abstract locations appearing in the source program using the info in the conflict graph.

Here is the initial algorithm. Another version is given afterwards.
- if the set of abstract locations is empty then return an empty assignment
- k = number of assignable registers. Choose a low-degree abstract location i.e. an abstract location with fewer than k conflicts if it exists. Otherwise choose an arbitrary abstract location.
- say that you have chosen the abstract location A.
  remove A from both the set of abstract locations and the conflict graph (two parameters
  of the algorithm). Call recursively the algorithm with those updated parameters.
  This gives you an assignment list for all abstract locations except A.
- Based on that information we try to assign A some physical location P.
  - first try to assign a register. P should not have been chosen by an abstract location in conflict with A
  - if it does not work, assign P a frame variable instead.

alternative algorithm?
- sort all abstract locations by degree (low degree first)
- for each abstract location, assign either a register or a frame variable based on the conflict criterion:
  for all P register, for all A A' locations,
  A conflicts with A' => [  (P assigned to A') => not(P assigned to A) ]

the graph coloring business appears in the reading because the algorithm we use is an adaptation of a graph colouring based register allocation mechanism.
